# 題目描述

這是一個關於陣列中重複數字的問題，目的是找出陣列中任意一個重複的數字。
ref:
https://github.com/CyC2018/CS-Notes/blob/master/notes/3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.md

## 題目說明

在一個長度為 n 的數組裡的所有數字都在 0 到 n-1 的範圍內。數組中某些數字是重複的，但不知道有幾個數字是重複的，也不知道每個數字重複幾次。請找出數組中任意一個重複的數字。
特殊要求: 空間複雜度 O(1)，時間複雜度 O(n)。

## 輸入範例

```
{2, 3, 1, 0, 2, 5}
```

## 輸出範例

```
2
```

## 解題提示 - 原地交換法說明

原地交換法 (In-place Swap Method) 是一種利用陣列本身來尋找重複數字的技巧，不需額外建立其他資料結構，因此**空間複雜度為 O (1)**。這個方法特別適用於「陣列長度為 n，且所有數字都在 0 ~ n-1 範圍內」的情境。

### 原理說明

- 目標：將每個數字放到與其值相同的索引位置上 (例如數字 2 放到 index 2)。
- 遍歷陣列時，若 nums [i] ≠ i，檢查 nums [i] 是否等於 nums [nums [i]]。
  - 若相等，代表 nums [i] 已經出現過 (重複)。
  - 若不相等，交換 nums [i] 與 nums [nums [i]]，直到 nums [i] == i 或找到重複。

### 步驟範例

以輸入 `{2, 3, 1, 0, 2, 5}` 為例：

1. **初始陣列**：`[2, 3, 1, 0, 2, 5]`
2. i = 0，nums [0] = 2 ≠ 0，nums [0] ≠ nums [2](2 ≠ 1)，交換 nums [0] 與 nums [2]  → `[1, 3, 2, 0, 2, 5]`
3. i = 0，nums [0] = 1 ≠ 0，nums [0] ≠ nums [1](1 ≠ 3)，交換 nums [0] 與 nums [1]  → `[3, 1, 2, 0, 2, 5]`
4. i = 0，nums [0] = 3 ≠ 0，nums [0] ≠ nums [3](3 ≠ 0)，交換 nums [0] 與 nums [3]  → `[0, 1, 2, 3, 2, 5]`
5. i = 0，nums [0] = 0 == 0，進入下一個 i
6. i = 1，nums [1] = 1 == 1，進入下一個 i
7. i = 2，nums [2] = 2 == 2，進入下一個 i
8. i = 3，nums [3] = 3 == 3，進入下一個 i
9. i = 4，nums[4] = 2 ≠ 4，nums[4] == nums[2](2 == 2)， **找到重複數字 2**

### 優缺點

- **優點**：不需額外記憶體 (空間複雜度 O (1))，速度快 (時間複雜度 O (n))。
- **缺點**：會改變原始陣列內容 (若原始資料需保留，請先複製陣列)。

### 小結

原地交換法利用「數字與索引對應」的特性，將每個數字放到正確位置，若發現某個位置已經有相同數字，代表出現重複。這種技巧常見於陣列元素範圍與索引一致的題目。
