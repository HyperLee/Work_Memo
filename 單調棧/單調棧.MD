應用題目:
84. Largest Rectangle in Histogram
https://leetcode.com/problems/largest-rectangle-in-histogram/description/

84. 柱状图中最大的矩形
https://leetcode.cn/problems/largest-rectangle-in-histogram/description/

題目描述:
我们用一个具体的例子 [6,7,5,2,4,5,9,3] 来帮助读者理解单调栈。我们需要求出每一根柱子的左侧且最近的小于其高度的柱子。初始时的栈为空。

    我们枚举 6，因为栈为空，所以 6 左侧的柱子是「哨兵」，位置为 -1。随后我们将 6 入栈。
        栈：[6(0)]。（这里括号内的数字表示柱子在原数组中的位置）

    我们枚举 7，由于 6<7，因此不会移除栈顶元素，所以 7 左侧的柱子是 6，位置为 0。随后我们将 7 入栈。
        栈：[6(0), 7(1)]

    我们枚举 5，由于 7≥5，因此移除栈顶元素 7。同样地，6≥5，再移除栈顶元素 6。此时栈为空，所以 5 左侧的柱子是「哨兵」，位置为 −1。随后我们将 5 入栈。
        栈：[5(2)]

    接下来的枚举过程也大同小异。我们枚举 2，移除栈顶元素 5，得到 2 左侧的柱子是「哨兵」，位置为 −1。将 2 入栈。
        栈：[2(3)]

    我们枚举 4，5 和 9，都不会移除任何栈顶元素，得到它们左侧的柱子分别是 2，4 和 5，位置分别为 3，4 和 5。将它们入栈。
        栈：[2(3), 4(4), 5(5), 9(6)]

    我们枚举 3，依次移除栈顶元素 9，5 和 4，得到 3 左侧的柱子是 2，位置为 3。将 3 入栈。
        栈：[2(3), 3(7)]

这样以来，我们得到它们左侧的柱子编号分别为 [−1,0,−1,−1,3,4,5,3]。用相同的方法，我们从右向左进行遍历，也可以得到它们右侧的柱子编号分别为 [2,2,3,8,7,7,7,8]，这里我们将位置 8 看作「哨兵」。


----------------------------------------------------------Grok推理
我將詳細解釋這段文字的意思，並說明「單調棧」的運作方式，以及左右兩側柱子編號的含義。以下是逐步分析與推理，幫助你理解這個數據結構及其應用。

---

### 什麼是單調棧？

「單調棧」是一種特殊的棧結構，棧內的元素保持單調性，也就是說，元素從棧底到棧頂要麼單調遞增，要麼單調遞減。在這個例子中，我們使用的是**單調遞增棧**，即棧內的元素從棧底到棧頂依次變大。這種特性讓我們可以快速找到數組中每個元素左右兩側最近的比它小的元素。

在這個問題中，給定一個數組 `[6,7,5,2,4,5,9,3]`，它代表一系列柱子的高度。我們的目標是對於數組中的每根柱子，找出：
1. **左側最近的比它矮的柱子**的位置。
2. **右側最近的比它矮的柱子**的位置。

---

### 求左側最近的較小柱子

我們從左到右遍歷數組，使用單調棧來找到每個柱子左側最近的比它矮的柱子。以下是具體過程：

#### 規則
- **初始化**：棧開始時是空的。
- **遍歷時**：
  - 如果棧頂的柱子高度大於或等於當前柱子高度，移除棧頂元素（因為這些較高的柱子不可能是當前柱子左側最近的較小柱子）。
  - 移除後，棧頂的柱子就是左側最近的比當前柱子矮的柱子。
  - 如果棧為空，則左側沒有比當前柱子矮的柱子，用「哨兵」表示，位置記為 `-1`。
  - 最後，將當前柱子入棧。

#### 遍歷數組 `[6,7,5,2,4,5,9,3]`
1. **柱子 6（位置 0）**：
   - 棧為空，左側是「哨兵」，位置為 `-1`。
   - 將 6 入棧，棧變為 `[6(0)]`。

2. **柱子 7（位置 1）**：
   - 棧頂是 6，6 < 7，不移除。
   - 左側最近的較小柱子是 6，位置為 `0`。
   - 將 7 入棧，棧變為 `[6(0), 7(1)]`。

3. **柱子 5（位置 2）**：
   - 棧頂是 7，7 ≥ 5，移除 7。
   - 現在棧頂是 6，6 ≥ 5，移除 6。
   - 棧為空，左側是「哨兵」，位置為 `-1`。
   - 將 5 入棧，棧變為 `[5(2)]`。

4. **柱子 2（位置 3）**：
   - 棧頂是 5，5 ≥ 2，移除 5。
   - 棧為空，左側是「哨兵」，位置為 `-1`。
   - 將 2 入棧，棧變為 `[2(3)]`。

5. **柱子 4（位置 4）**：
   - 棧頂是 2，2 < 4，不移除。
   - 左側最近的較小柱子是 2，位置為 `3`。
   - 將 4 入棧，棧變為 `[2(3), 4(4)]`。

6. **柱子 5（位置 5）**：
   - 棧頂是 4，4 < 5，不移除。
   - 左側最近的較小柱子是 4，位置為 `4`。
   - 將 5 入棧，棧變為 `[2(3), 4(4), 5(5)]`。

7. **柱子 9（位置 6）**：
   - 棧頂是 5，5 < 9，不移除。
   - 左側最近的較小柱子是 5，位置為 `5`。
   - 將 9 入棧，棧變為 `[2(3), 4(4), 5(5), 9(6)]`。

8. **柱子 3（位置 7）**：
   - 棧頂是 9，9 ≥ 3，移除 9。
   - 棧頂是 5，5 ≥ 3，移除 5。
   - 棧頂是 4，4 ≥ 3，移除 4。
   - 現在棧頂是 2，2 < 3，不移除。
   - 左側最近的較小柱子是 2，位置為 `3`。
   - 將 3 入棧，棧變為 `[2(3), 3(7)]`。

#### 結果
通過以上過程，我們得到每個柱子左側最近的較小柱子的位置：
- **左側柱子編號**：`[-1, 0, -1, -1, 3, 4, 5, 3]`。
  - 例如：
    - 柱子 6（位置 0）：左側無較小柱子，記為 `-1`。
    - 柱子 7（位置 1）：左側是 6（位置 0）。
    - 柱子 3（位置 7）：左側是 2（位置 3）。

---

### 求右側最近的較小柱子

我們從右到左遍歷數組，找到每個柱子右側最近的比它矮的柱子。過程與左側類似，只是方向相反。

#### 規則
- **初始化**：棧開始時是空的。
- **遍歷時**：
  - 如果棧頂的柱子高度大於或等於當前柱子高度，移除棧頂元素。
  - 移除後，棧頂的柱子就是右側最近的比當前柱子矮的柱子。
  - 如果棧為空，則右側沒有比當前柱子矮的柱子，用「哨兵」表示，位置記為 `8`（數組長度為 8，超出範圍）。
  - 最後，將當前柱子入棧。

#### 遍歷數組 `[6,7,5,2,4,5,9,3]`
1. **柱子 3（位置 7）**：
   - 棧為空，右側是「哨兵」，位置為 `8`。
   - 將 3 入棧，棧變為 `[3(7)]`。

2. **柱子 9（位置 6）**：
   - 棧頂是 3，3 < 9，不移除。
   - 右側最近的較小柱子是 3，位置為 `7`。
   - 將 9 入棧，棧變為 `[3(7), 9(6)]`。

3. **柱子 5（位置 5）**：
   - 棧頂是 9，9 ≥ 5，移除 9。
   - 棧頂是 3，3 < 5，不移除。
   - 右側最近的較小柱子是 3，位置為 `7`。
   - 將 5 入棧，棧變為 `[3(7), 5(5)]`。

4. **柱子 4（位置 4）**：
   - 棧頂是 5，5 ≥ 4，移除 5。
   - 棧頂是 3，3 < 4，不移除。
   - 右側最近的較小柱子是 3，位置為 `7`。
   - 將 4 入棧，棧變為 `[3(7), 4(4)]`。

5. **柱子 2（位置 3）**：
   - 棧頂是 4，4 ≥ 2，移除 4。
   - 棧頂是 3，3 ≥ 2，移除 3。
   - 棧為空，右側是「哨兵」，位置為 `8`。
   - 將 2 入棧，棧變為 `[2(3)]`。

6. **柱子 5（位置 2）**：
   - 棧頂是 2，2 < 5，不移除。
   - 右側最近的較小柱子是 2，位置為 `3`。
   - 將 5 入棧，棧變為 `[2(3), 5(2)]`。

7. **柱子 7（位置 1）**：
   - 棧頂是 5，5 < 7，不移除。
   - 右側最近的較小柱子是 5，位置為 `2`。
   - 將 7 入棧，棧變為 `[2(3), 5(2), 7(1)]`。

8. **柱子 6（位置 0）**：
   - 棧頂是 7，7 ≥ 6，移除 7。
   - 棧頂是 5，5 < 6，不移除。
   - 右側最近的較小柱子是 5，位置為 `2`。
   - 將 6 入棧，棧變為 `[2(3), 5(2), 6(0)]`。

#### 結果
通過以上過程，我們得到每個柱子右側最近的較小柱子的位置：
- **右側柱子編號**：`[2, 2, 3, 8, 7, 7, 7, 8]`。
  - 例如：
    - 柱子 6（位置 0）：右側是 5（位置 2）。
    - 柱子 2（位置 3）：右側無較小柱子，記為 `8`。
    - 柱子 9（位置 6）：右側是 3（位置 7）。

---

### 總結：左右兩側柱子編號的含義

- **左側柱子編號**：`[-1, 0, -1, -1, 3, 4, 5, 3]`  
  - 這表示數組中每個柱子左側最近的比它矮的柱子的位置。
  - `-1` 表示左側沒有比當前柱子矮的柱子（即左邊界外）。
  - 例如：
    - 位置 1（柱子 7）：左側是位置 0（柱子 6）。
    - 位置 4（柱子 4）：左側是位置 3（柱子 2）。

- **右側柱子編號**：`[2, 2, 3, 8, 7, 7, 7, 8]`  
  - 這表示數組中每個柱子右側最近的比它矮的柱子的位置。
  - `8` 表示右側沒有比當前柱子矮的柱子（即右邊界外）。
  - 例如：
    - 位置 0（柱子 6）：右側是位置 2（柱子 5）。
    - 位置 3（柱子 2）：右側無較小柱子，記為 `8`。

---

### 單調棧的意義

單調棧通過維護棧內元素的單調性，讓我們能在 O(n) 的時間內高效找到每個元素左右兩側最近的較小元素。這種方法在許多問題中都有應用，例如計算柱狀圖中的最大矩形面積等。希望這個詳細的解釋能幫助你理解單調棧及其運作原理！


-----------------------------GPT推理 
这段文字讲解了如何利用单调栈来求解每根柱子左侧（或右侧）最近一个比其高度小的柱子的位置。下面我们分步解释这个过程以及如何得到左右两侧柱子对应的编号。

---

### 基本思想

- **单调栈**是一种数据结构，保持栈内元素单调（这里是单调递增），从而在遍历过程中可以快速找到某个元素左侧或右侧最近的较小值。
- 当遍历每个柱子时，我们依次检查栈顶元素：  
  - 如果栈顶的高度小于当前柱子的高度，则栈顶就是当前柱子左侧（或右侧）最近的较小柱子。  
  - 如果栈顶高度大于或等于当前柱子的高度，就将栈顶元素弹出，直到找到一个较小的或栈为空。

---

### 左侧柱子编号的求法

以数组 `[6,7,5,2,4,5,9,3]` 为例，编号从 0 开始，初始时我们定义“哨兵”为 -1，表示在当前柱子左侧没有比其高度更小的柱子。具体步骤如下：

1. **柱子 6 (位置 0)**  
   - 栈为空，因此 6 左侧没有柱子，记为哨兵 `-1`。  
   - 入栈后，栈为：`[6(0)]`。

2. **柱子 7 (位置 1)**  
   - 当前栈顶是 6，而 `6 < 7`，所以 7 左侧最近较小的柱子是 6，编号为 0。  
   - 入栈后，栈为：`[6(0), 7(1)]`。

3. **柱子 5 (位置 2)**  
   - 当前栈顶为 7，但 `7 ≥ 5`，所以弹出 7；  
   - 接着栈顶变为 6，`6 ≥ 5`，也弹出 6；  
   - 栈为空，说明 5 左侧没有较小的柱子，记为哨兵 `-1`。  
   - 入栈后，栈为：`[5(2)]`。

4. **柱子 2 (位置 3)**  
   - 当前栈顶为 5，`5 ≥ 2`，弹出 5；  
   - 栈为空，因此 2 的左侧为哨兵 `-1`。  
   - 入栈后，栈为：`[2(3)]`。

5. **柱子 4 (位置 4)**  
   - 当前栈顶为 2，`2 < 4`，所以 4 左侧最近较小的柱子是 2，编号为 3。  
   - 入栈后，栈为：`[2(3), 4(4)]`。

6. **柱子 5 (位置 5)**  
   - 当前栈顶为 4，`4 < 5`，所以 5 左侧最近较小的柱子是 4，编号为 4。  
   - 入栈后，栈为：`[2(3), 4(4), 5(5)]`。

7. **柱子 9 (位置 6)**  
   - 当前栈顶为 5，`5 < 9`，因此 9 左侧最近较小的柱子是 5，编号为 5。  
   - 入栈后，栈为：`[2(3), 4(4), 5(5), 9(6)]`。

8. **柱子 3 (位置 7)**  
   - 当前栈顶为 9，`9 ≥ 3`，弹出 9；  
   - 新的栈顶为 5，`5 ≥ 3`，弹出 5；  
   - 新的栈顶为 4，`4 ≥ 3`，弹出 4；  
   - 剩下栈顶为 2，`2 < 3`，因此 3 左侧最近较小的柱子是 2，编号为 3。  
   - 入栈后，栈为：`[2(3), 3(7)]`。

**最终得到左侧柱子的编号序列为：**  
`[-1, 0, -1, -1, 3, 4, 5, 3]`

---

### 右侧柱子编号的求法

求右侧最近较小的柱子编号可以采用与左侧类似的方法，只不过遍历顺序变为从右向左。我们同样用一个单调栈来维护右侧较小柱子的位置，并用一个哨兵值（这里记为位置 8，因为数组长度为 8）表示没有找到较小的柱子。

具体思路如下（从右向左遍历）：

1. **柱子 3 (位置 7)**  
   - 栈为空，因此 3 右侧没有柱子，记为哨兵 `8`。  
   - 入栈后，栈为：`[3(7)]`。

2. **柱子 9 (位置 6)**  
   - 当前栈顶为 3，`3 < 9`，所以 9 右侧最近较小的柱子为 3，编号为 7。  
   - 入栈后，栈为：`[3(7), 9(6)]`。

3. **柱子 5 (位置 5)**  
   - 当前栈顶为 9，`9 ≥ 5`，弹出 9；  
   - 新的栈顶为 3，`3 < 5`，所以 5 右侧最近较小的柱子为 3，编号为 7。  
   - 入栈后，栈为：`[3(7), 5(5)]`。

4. **柱子 4 (位置 4)**  
   - 当前栈顶为 5，`5 ≥ 4`，弹出 5；  
   - 新的栈顶为 3，`3 < 4`，所以 4 右侧最近较小的柱子为 3，编号为 7。  
   - 入栈后，栈为：`[3(7), 4(4)]`。

5. **柱子 2 (位置 3)**  
   - 当前栈顶为 4，`4 ≥ 2`，弹出 4；  
   - 新的栈顶为 3，`3 ≥ 2`，弹出 3；  
   - 栈为空，因此 2 右侧没有较小的柱子，记为哨兵 `8`。  
   - 入栈后，栈为：`[2(3)]`。

6. **柱子 5 (位置 2)**  
   - 当前栈顶为 2，`2 < 5`，所以 5 右侧最近较小的柱子为 2，编号为 3。  
   - 入栈后，栈为：`[2(3), 5(2)]`。

7. **柱子 7 (位置 1)**  
   - 当前栈顶为 5，`5 < 7`，所以 7 右侧最近较小的柱子为 5，编号为 2。  
   - 入栈后，栈为：`[2(3), 5(2), 7(1)]`。

8. **柱子 6 (位置 0)**  
   - 当前栈顶为 7，`7 ≥ 6`，弹出 7；  
   - 新的栈顶为 5，`5 < 6`，所以 6 右侧最近较小的柱子为 5，编号为 2。  
   - 入栈后，栈为：`[2(3), 5(2), 6(0)]`。

**最终得到右侧柱子的编号序列为：**  
`[2, 2, 3, 8, 7, 7, 7, 8]`

> 注意：这里的位置编号指的是原数组中柱子的索引。如果右侧没有比当前柱子更小的，就使用哨兵位置（对于左侧用 -1，对于右侧用数组长度，即 8）来表示。

---

### 总结

- **左侧遍历：**  
  从左到右，每个柱子找到其左侧最近比它矮的柱子，若无则为哨兵 -1。最终结果为 `[-1, 0, -1, -1, 3, 4, 5, 3]`。

- **右侧遍历：**  
  从右到左，每个柱子找到其右侧最近比它矮的柱子，若无则为哨兵（这里取数组长度 8）。最终结果为 `[2, 2, 3, 8, 7, 7, 7, 8]`。

这种方法在很多问题中非常有用，例如求直方图中最大矩形面积、股票跨度问题等。通过单调栈的特性，可以在 \(O(n)\) 的时间复杂度内高效计算出所需结果。